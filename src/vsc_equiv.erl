-module(vsc_equiv).
-compile(export_all). % Exports all functions
-compile(debug_info).

-include_lib("proper/include/proper.hrl").

% 1. Create tmp dir and copy/symlink the .git folder (TODO libgit bindings instead of CLI)
% 2. Checkout the original code                      (TODO only checkout files that are necessary)
% 3. Run the tests (compile, run)                    (TODO compile only the necessary modules, for now I assumed that the functions don't use other modules)
% 4. Checkout the refactored code
% 5. Run the tests with PropEr
% 6. Give back the counterexample if it fails
% 7. Delete tmp


recreate_project(ProjFolder) ->
    % TODO tmp should be somewhere in /tmp
    % {_, Dir} = file:get_cwd(),
    file:make_dir("tmp"),
    % file:make_symlink(Dir ++ "/.git", Dir ++ "/tmp/.git").
    os:cmd("git clone " ++ ProjFolder ++ " tmp").

checkout(Hash) ->
    os:cmd("git checkout " ++ Hash).

cleanup() ->
    file:del_dir_r("tmp").

% 1. Check where was the function used (assume we know the parameters)
% 2. Compile these modules (assume the function doesn't call anything from other modules)
% 3. Call each function with data generated by PropEr

comp(FunName, ProjFolder, DirName) ->
    {_, Funs} = wrangler_code_inspector_lib:calls_to_fun_1("test.erl", FunName, 1, [ProjFolder], 4), % TODO Get module name somehow
    Modules = lists:uniq(lists:map(fun(X) -> element(1, element(1, X)) end, Funs)),
    file:make_dir(DirName),
    lists:map(fun(X) -> compile:file(X, {outdir, DirName}) end, Modules).

comp(Modules, DirName) ->
    file:make_dir(DirName),
    lists:map(fun(X) -> compile:file(X, {outdir, DirName}) end, Modules).

check_equiv(OrigHash, RefacHash, OrigName, RefacName) ->
    application:start(wrangler), % TODO
    {_, ProjFolder} = file:get_cwd(),
    recreate_project(ProjFolder),
    file:set_cwd("tmp"), % TODO Change this to something like /tmp later

    % Checkout and compile the necessary modules into two separate folders
    % This is needed because QuickCheck has to evaluate to old and the new
    % function repeatedly side-by-side
    checkout(OrigHash),
    comp(OrigName, ProjFolder, "orig"),

    checkout(RefacHash),
    comp(RefacName, ProjFolder, "refac"),

    {OrigNode, RefacNode} = start_nodes(),

    % Generate random data (assume we know the type of data for now) and check
    % if the outputs are equivalent
    % RES = proper:quickcheck(?FORALL(I, integer(), prop_same_output(OrigNode, RefacNode, test, f_old, f_new, [I]))), % TODO Give back the minimal input that falsifies the assertion
    RES = proper:quickcheck(?FORALL(L, list(integer()), prop_same_output(OrigNode, RefacNode, test, OrigName, RefacName, [L]))), % TODO Give back the minimal input that falsifies the assertion

    file:set_cwd(".."),
    cleanup(),
    stop_nodes(OrigNode, RefacNode),
    application:stop(wrangler), % TODO
    RES.

check_equiv(OrigHash, RefacHash) ->
    application:start(wrangler), % TODO
    {_, ProjFolder} = file:get_cwd(),
    recreate_project(ProjFolder),
    file:set_cwd("tmp"), % TODO Change this to something like /tmp later

    [OrigFun, RefacFun] = general_refac:diffing(OrigHash, RefacHash),
    ChangedFile = general_refac:get_filename(element(1,RefacFun)),
    CallerFiles = general_refac:find_callers(RefacFun),

    Modules = lists:uniq([ChangedFile|CallerFiles]),

    % Checkout and compile the necessary modules into two separate folders
    % This is needed because QuickCheck has to evaluate to old and the new
    % function repeatedly side-by-side
    checkout(OrigHash),
    comp(Modules, "orig"),

    checkout(RefacHash),
    comp(Modules, "refac"),

    % Hard-coded for now
    start_nodes(),
    OrigNode = 'orig@x200s',
    RefacNode = 'refac@x200s',

    % TODO Modify this to run the tests on all the functions, using their spec to generate data
    % Generate random data (assume we know the type of data for now) and check
    % if the outputs are equivalent
    % RES = proper:quickcheck(?FORALL(I, integer(), prop_same_output(OrigNode, RefacNode, test, f_old, f_new, [I]))), % TODO Give back the minimal input that falsifies the assertion
    % RES = proper:quickcheck(?FORALL(L, list(integer()), prop_same_output(OrigNode, RefacNode, test, OrigName, RefacName, [L]))), % TODO Give back the minimal input that falsifies the assertion

    file:set_cwd(".."),
    cleanup(),
    application:stop(wrangler). % TODO
    % RES.

start_nodes() ->
    {_, Orig, _} = peer:start(#{name => orig, connection => 33001, args => ["-pa", "orig"]}),
    {_, Refac, _} = peer:start(#{name => refac, connection => 33002, args => ["-pa", "refac"]}),
    {Orig, Refac}.

stop_nodes(Orig, Refac) ->
    peer:stop(Orig),
    peer:stop(Refac).

prop_same_output(OrigNode, RefacNode, Module, OldName, NewName, Args) ->
    % Spawns a process on each node that evaluates the function and
    % sends back the result to this process
    
    A = peer:call(OrigNode, Module, OldName, Args),
    B = peer:call(RefacNode, Module, NewName, Args),

    A =:= B.
