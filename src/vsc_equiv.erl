-module(vsc_equiv).
-compile(export_all). % Exports all functions
-compile(debug_info).

-include_lib("proper/include/proper.hrl").

% 1. Create tmp dir and copy/symlink the .git folder (TODO libgit bindings instead of CLI)
% 2. Checkout the original code                      (TODO only checkout files that are necessary)
% 3. Run the tests (compile, run)                    (TODO compile only the necessary modules, for now I assumed that the functions don't use other modules)
% 4. Checkout the refactored code
% 5. Run the tests with PropEr
% 6. Give back the counterexample if it fails
% 7. Delete tmp


recreate_project(ProjFolder) ->
    % TODO tmp should be somewhere in /tmp
    % {_, Dir} = file:get_cwd(),
    file:make_dir("tmp"),
    % file:make_symlink(Dir ++ "/.git", Dir ++ "/tmp/.git").
    os:cmd("git clone " ++ ProjFolder ++ " tmp").

checkout(Hash) ->
    os:cmd("git checkout " ++ Hash).

cleanup() ->
    file:del_dir_r("tmp").

% 1. Check where was the function used (assume we know the parameters)
% 2. Compile these modules (assume the function doesn't call anything from other modules)
% 3. Call each function with data generated by PropEr

comp(FunName, ProjFolder, DirName) ->
    {_, Funs} = wrangler_code_inspector_lib:calls_to_fun_1("test.erl", FunName, 1, [ProjFolder], 4), % TODO Get module name somehow
    Modules = lists:uniq(lists:map(fun(X) -> element(1, element(1, X)) end, Funs)),
    file:make_dir(DirName),
    lists:map(fun(X) -> compile:file(X) end, Modules).

comp(Modules, DirName) ->
    file:make_dir(DirName),
    lists:map(fun(X) -> compile:file(X, [{outdir, DirName}, {warn_format, 0}]) end, Modules).

check_equiv(OrigHash, RefacHash, OrigName, RefacName) ->
    application:start(wrangler), % TODO
    {_, ProjFolder} = file:get_cwd(),
    recreate_project(ProjFolder),
    file:set_cwd("tmp"), % TODO Change this to something like /tmp later

    % Checkout and compile the necessary modules into two separate folders
    % This is needed because QuickCheck has to evaluate to old and the new
    % function repeatedly side-by-side
    checkout(OrigHash),
    comp(OrigName, ProjFolder, "orig"),

    checkout(RefacHash),
    comp(RefacName, ProjFolder, "refac"),

    {OrigNode, RefacNode} = start_nodes(),

    % Generate random data (assume we know the type of data for now) and check
    % if the outputs are equivalent
    % RES = proper:quickcheck(?FORALL(I, integer(), prop_same_output(OrigNode, RefacNode, test, f_old, f_new, [I]))), % TODO Give back the minimal input that falsifies the assertion
    % RES = proper:quickcheck(?FORALL(L, list(integer()), prop_same_output(OrigNode, RefacNode, test, OrigName, RefacName, [L]))), % TODO Give back the minimal input that falsifies the assertion

    file:set_cwd(".."),
    cleanup(),
    stop_nodes(OrigNode, RefacNode),
    application:stop(wrangler). % TODO
    %RES.

check_equiv(OrigHash, RefacHash) ->
    application:start(wrangler), % TODO
    {_, ProjFolder} = file:get_cwd(),

    recreate_project(ProjFolder),
    file:set_cwd("tmp"), % TODO Change this to something like /tmp later

    {ChangedFile, {OrigFun, RefacFun}, Arity} = general_refac:diff_renaming(OrigHash, RefacHash),
    Callers = general_refac:find_callers({RefacFun, Arity}),

    CallerFiles = lists:map(fun({FileName, _, _}) -> FileName end, Callers),

    Modules = lists:uniq([ChangedFile|CallerFiles]),

    % Checkout and compile the necessary modules into two separate folders
    % This is needed because QuickCheck has to evaluate to old and the new
    % function repeatedly side-by-side
    checkout(OrigHash),
    comp(Modules, "orig"),

    checkout(RefacHash),
    comp(Modules, "refac"),

    {OrigNode, RefacNode} = start_nodes(),

    % Contains all the functions that call the renamed one {Module, Function, PropEr Type}
    Funs = lists:map(fun({FileName, F, A}) -> {get_module(FileName), erlang:list_to_atom(F), get_type(hd(general_refac:get_args(FileName, F, A)))} end, Callers),

    lists:map(fun({FileName, F, A}) -> general_refac:get_args(FileName, F, A) end, Callers),

    Options = [quiet, long_result],
    Res = lists:filter(fun({_, _, Eq}) -> Eq =/= true end, lists:map(fun({M, F, Type}) -> {M, F, proper:quickcheck(?FORALL(X, Type, prop_same_output(OrigNode, RefacNode, M, F, [X])), Options)} end, Funs)),

    file:set_cwd(".."),
    cleanup(),
    stop_nodes(OrigNode, RefacNode),
    application:stop(wrangler), % TODO
    Res.

show_result(Res) ->
    io:format("Results: ~p~n", [Res]).

% TODO find some bigger erlang project with refactorings that can be tested

get_type(T) ->
    if
        T =:= "list(integer())" -> proper_types:list(integer());
        T =:= "integer()" -> proper_types:integer()
    end.

get_module(FileName) ->
    erlang:list_to_atom(hd(string:split(lists:last(string:split(FileName,"/",all)),"."))).

start_nodes() ->
    {_, Orig, _} = peer:start(#{name => orig, connection => 33001, args => ["-pa", "orig"]}),
    {_, Refac, _} = peer:start(#{name => refac, connection => 33002, args => ["-pa", "refac"]}),
    {Orig, Refac}.

stop_nodes(Orig, Refac) ->
    peer:stop(Orig),
    peer:stop(Refac).

prop_same_output(OrigNode, RefacNode, M, F, A) ->
    % Spawns a process on each node that evaluates the function and
    % sends back the result to this process
    
    % TODO Try peer:cast function
    Out1 = peer:call(OrigNode, M, F, A),
    Out2 = peer:call(RefacNode, M, F, A),

    Out1 =:= Out2.
